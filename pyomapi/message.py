# Copyright 2018 Ruben Quinones (ruben.quinones@rackspace.com)
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

import secrets

import msgpack


class OMAPIMessage:
    # OP codes
    OP_OMAPI_OPEN = 1
    OP_OMAPI_REFRESH = 2
    OP_OMAPI_UPDATE = 3
    OP_OMAPI_NOTIFY = 4
    OP_OMAPI_STATUS = 5
    OP_OMAPI_DELETE = 6

    # OP code map
    OP_MAP = {
        OP_OMAPI_OPEN: 'open',
        OP_OMAPI_REFRESH: 'refresh',
        OP_OMAPI_UPDATE: 'update',
        OP_OMAPI_NOTIFY: 'notify',
        OP_OMAPI_STATUS: 'status',
        OP_OMAPI_DELETE: 'delete',
    }
    """
    @type authid: int
    @ivar authid: The id of the message authenticator.
    @type opcode: int
    @ivar opcode: One out of
            OMAPI_OP_{OPEN,REFRESH,UPDATE,NOTIFY,STATUS,DELETE}.
    @type handle: int
    @ivar handle: The id of a handle acquired from a previous request or 0.
    @type tid: int
    @ivar tid: Transmissifon identifier.
    @type rid: int
    @ivar rid: Receive identifier (of a response is the tid of the request).
    @type message: [(bytes, bytes)]
    @ivar message: A list of (key, value) pairs.
    @type obj: [(bytes, bytes)]
    @ivar obj: A list of (key, value) pairs.
    @type signature: bytes
    @ivar signature: A signature on this message as generated by an
            authenticator.
    """

    def __init__(self, auth_id=0, opcode=0, handle=0, transmission_id=b'',
                 response_id=b'', message=[], obj=[], signature=b''):
        self.auth_id = auth_id
        self.opcode = opcode
        self.handle = handle
        self.transmission_id = transmission_id
        self.response_id = response_id
        self.message = message
        self.obj = obj
        self.signature = signature

        if not self.transmission_id:
            self.set_transmission_id()

    def set_transmission_id(self):
        """
        Generate and assign a random transmission id for this message.
        :return: None
        """
        self.transmission_id = secrets.token_bytes()

    def pack(self, sign=True):
        """
        @type outbuffer: OutBuffer
        @type forsigning: bool
        @raises OmapiSizeLimitError:
        """
        data = [
            len(self.signature),
            self.opcode,
            self.handle,
            self.transmission_id,
            self.response_id,
            self.message,
            self.obj,
        ]

        if sign:
            data.insert(0, self.auth_id)
            data.append(self.signature)

        packed_data = msgpack.packb(data, use_bin_type=True)
        return packed_data

    def sign(self, authenticator):
        """Sign this OMAPI message.
        @type authenticator: OmapiAuthenticatorBase
        """
        self.auth_id = authenticator.auth_id
        self.signature = authenticator.sign(self.pack(sign=False))

        if len(self.signature) != authenticator.auth_length:
            raise Exception

    def verify(self, authenticator):
        """
        Verify the signature of this OMAPI message.
        :param authenticator: 
        :return: 
        """
        signature = authenticator.sign(self.pack(sign=False))
        return signature == self.signature

    @classmethod
    def open(cls, type_name):
        """Create an OMAPI open message with given typename.
        @type typename: bytes
        @rtype: OmapiMessage
        """
        return cls(opcode=OP_OMAPI_OPEN, message=[('type', type_name)])

    @classmethod
    def update(cls, handle):
        """Create an OMAPI update message for the given handle.
        @type handle: int
        @rtype: OmapiMessage
        """
        return cls(opcode=cls.OP_OMAPI_UPDATE, handle=handle)

    @classmethod
    def delete(cls, handle):
        """Create an OMAPI delete message for given handle.
        @type handle: int
        @rtype: OmapiMessage
        """
        return cls(opcode=cls.OP_OMAPI_DELETE, handle=handle)

    def is_response(self, message):
        """Check whether this OMAPI message is a response to the given
        OMAPI message.

        """
        return self.response_id == message.transmission_id

    def update_object(self, update):
        """
        @type update: {bytes: bytes}
        """
        self.obj = [(key, value) for key, value in self.obj if key not in update]
        self.obj.extend(update.items())
